CODIGO Q SE USO PARA ENTRENAR EL MODELO

import ccxt
import pandas as pd
import os
import time
from dotenv import load_dotenv

# Cargar credenciales desde archivo .env
load_dotenv()

# Configurar conexi√≥n con Kraken
api_key = os.getenv("KRAKEN_API_KEY")
api_secret = os.getenv("KRAKEN_API_SECRET")

exchange = ccxt.kraken({
'apiKey': api_key,
'secret': api_secret
})

# Par√°metros del mercado
symbol = 'XXBTZUSD' # Kraken usa XXBTZUSD para BTC/USD
timeframe = '1h' # Usamos 1 hora para agrupar en 2 horas
limit = 500 # M√°ximo permitido por Kraken

# Verificar conexi√≥n con Kraken
try:
print(f"Probando conexi√≥n con Kraken y verificando s√≠mbolo: {symbol}")
ticker = exchange.fetch_ticker(symbol)
print(f"‚úÖ Conexi√≥n exitosa. Precio actual de {symbol}: {ticker['last']}")
except Exception as e:
print(f"‚ùå Error al conectar con Kraken: {e}")
exit()

# Funci√≥n para calcular indicadores
def calculate_indicators(df):
# Resampling para asegurar que los datos est√©n en el marco de tiempo de 2 horas
df = df.set_index('timestamp').resample('2h').agg({'open': 'first', 'high': 'max', 'low': 'min', 'close': 'last', 'volume': 'sum'}).dropna()

# C√°lculo de la EMA de 50
df['EMA50'] = df['close'].ewm(span=50, adjust=False).mean()

# C√°lculo de la EMA de 12 y 26
df['EMA12'] = df['close'].ewm(span=12, adjust=False).mean() # EMA de corto plazo
df['EMA26'] = df['close'].ewm(span=26, adjust=False).mean() # EMA de largo plazo

# C√°lculo del MACD
df['MACD'] = df['EMA12'] - df['EMA26'] # MACD = EMA12 - EMA26
df['MACD_signal'] = df['MACD'].ewm(span=9, adjust=False).mean() # Signal = EMA9(MACD)

# C√°lculo del RSI (14 per√≠odos)
delta = df['close'].diff() # Cambios diarios
gain = (delta.where(delta > 0, 0)).rolling(window=14).mean() # Ganancia media
loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean() # P√©rdida media
rs = gain / loss # Relaci√≥n de fuerza
df['RSI'] = 100 - (100 / (1 + rs)) # RSI

# Detecci√≥n de patrones de velas
df['doji'] = abs(df['close'] - df['open']) / (df['high'] - df['low']) < 0.1
df['hammer'] = (df['close'] - df['open']).abs() < (df['high'] - df['low']) * 0.3
df['hammer'] &= (df['low'] - df['open']) > (df['high'] - df['close'])
df['bullish_engulfing'] = (df['close'] > df['open']) & (df['open'].shift(1) > df['close'].shift(1)) & (df['close'] > df['open'].shift(1)) & (df['open'] < df['close'].shift(1))
df['bearish_engulfing'] = (df['close'] < df['open']) & (df['open'].shift(1) < df['close'].shift(1)) & (df['close'] < df['open'].shift(1)) & (df['open'] > df['close'].shift(1))
df['shooting_star'] = (df['close'] - df['open']).abs() < (df['high'] - df['low']) * 0.3
df['shooting_star'] &= (df['high'] - df['close']) > (df['close'] - df['open'])
df['morning_star'] = (df['close'].shift(2) < df['open'].shift(2)) & (df['open'].shift(1) < df['close'].shift(1)) & (df['close'] > df['open'])
df['evening_star'] = (df['close'].shift(2) > df['open'].shift(2)) & (df['open'].shift(1) > df['close'].shift(1)) & (df['close'] < df['open'])

# Asegurarse de que no haya valores NaN
return df.dropna()

# Funci√≥n para guardar la Q-table
def save_q_table():
q_table.to_csv("q_table.csv", index=False)

# Cargar tabla Q desde archivo (si existe)
if os.path.exists("q_table.csv"):
q_table = pd.read_csv("q_table.csv")
else:
q_table = pd.DataFrame()

# Funci√≥n para imprimir balance y estad√≠sticas
def print_balance():
global total_profit, operation_count, balance
if operation_count > 0:
profit_percentage = (total_profit / (balance + total_profit)) * 100
else:
profit_percentage = 0

print(f"\nüìä Balance: {balance:.2f} USD")
print(f"üîÑ Total de operaciones: {operation_count}")
print(f"üí∞ Ganancia total: {total_profit:.2f} USD")
print(f"üìà Porcentaje de ganancia: {profit_percentage:.2f}%")
print(f"‚úÖ Operaciones exitosas: {operation_count}") # Agregado
print(f"‚öñÔ∏è Balance total: {balance + total_profit:.2f} USD") # Agregado

# Variables para el seguimiento del balance y operaciones
balance = 1000 # Ejemplo de saldo inicial
total_profit = 0
operation_count = 0
position = None
entry_price = 0

# Bucle principal para operar en tiempo real
start_time = time.time()
while True:
try:
# Obtener datos de mercado en tiempo real
ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit)
df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

# Calcular indicadores
df = calculate_indicators(df)

# Estrategia 1: Basada en Indicadores Principales
for i in range(1, len(df)):
try:
price = df['close'].iloc[i]

# Detectar variaciones significativas en los indicadores
buy_signal, sell_signal = check_buy_sell_signals(df, i)

# Condiciones para realizar la compra o venta
if position is None and buy_signal:
position, entry_price = 'BUY', price
amount_to_buy = balance / price
balance -= amount_to_buy * price
operation_count += 1

elif position == 'BUY' and sell_signal:
balance += price # Simular la venta
position = None
profit = price - entry_price
total_profit += profit
operation_count += 1

# Estrategia 2: Patrones de Velas y Soporte/Resistencia
if position is None and not buy_signal and not sell_signal:
if df.iloc[i]['doji'] or df.iloc[i]['hammer'] or df.iloc[i]['morning_star']:
position, entry_price = 'BUY', price
amount_to_buy = balance / price
balance -= amount_to_buy * price
operation_count += 1

elif df.iloc[i]['shooting_star'] or df.iloc[i]['bearish_engulfing'] or df.iloc[i]['evening_star']:
balance += price # Simular la venta
position = None
profit = price - entry_price
total_profit += profit
operation_count += 1

# Estrategia 3: Monitoreo de Variaciones y Patrones de Velas
if position is None:
if price > entry_price * 1.002: # Subida de 0.2%
position, entry_price = 'BUY', price
amount_to_buy = balance / price
balance -= amount_to_buy * price
operation_count += 1
elif price < entry_price * 0.998: # Bajada de 0.2%
balance += price
position = None
profit = entry_price - price
total_profit += profit
operation_count += 1

# Re-evaluar la operaci√≥n si hay una variaci√≥n importante en los precios
if position == 'BUY':
if price >= entry_price * 1.003: # Subida de 0.3% despu√©s de compra
balance += price # Simular la venta
position = None
profit = price - entry_price
total_profit += profit
operation_count += 1

# Guardar la tabla Q cada vez
save_q_table()

except Exception as e:
print(f"‚ùå Error en el ciclo (√≠ndice {i}): {str(e)}")
time.sleep(10) # Espera antes de intentar nuevamente

# Imprimir balance y estad√≠sticas cada 5 minutos
if time.time() - start_time >= 300: # 300 segundos = 5 minutos
print_balance()
start_time = time.time()

time.sleep(60) # Espera antes de la siguiente iteraci√≥n

except Exception as e:
print(f"‚ùå Error general: {str(e)}")
time.sleep(10) # Espera antes de intentar nuevamente


DATOS PARA QUE EL MODELO SE INCERTE A KRAKEN

Obtener los Datos de Kraken:

    Ya tienes el c√≥digo para conectar a la API de Kraken y obtener datos hist√≥ricos de XXBTZUSD.

    Los par√°metros que debes obtener son los precios de apertura, precio de cierre, volumen, m√°ximo y m√≠nimo. Estos son los 5 par√°metros que el modelo utilizar√° para hacer las predicciones.

2. Procesar los Datos Antes de Pas√°rselos al Modelo: Antes de enviar los datos al modelo de IA, necesitas realizar algunos procesos de pretratamiento:

    C√°lculo de Indicadores T√©cnicos: El modelo fue entrenado con indicadores t√©cnicos como la EMA, MACD, RSI, etc. Esto significa que los datos que pasas al modelo deben incluir estos indicadores, no solo los precios hist√≥ricos.

    Por ejemplo, tienes que calcular:

        EMA50 (Media M√≥vil Exponencial de 50 per√≠odos)

        EMA12 y EMA26 (para MACD)

        MACD (Diferencia entre EMA12 y EMA26)

        RSI (√çndice de Fuerza Relativa)

        Patrones de Velas como Doji, Hammer, etc.

    Redondeo y Normalizaci√≥n de los Datos:

        Los datos deben ser normalizados (escalados) antes de ser introducidos en el modelo. Esto significa que los valores num√©ricos de los precios y otros indicadores deben estar dentro de un rango espec√≠fico, como de 0 a 1, utilizando m√©todos como MinMaxScaler de Scikit-learn o normalizaci√≥n similar.

    Organizaci√≥n de los Datos en Ventanas de 50 Momentos:

        El modelo espera una entrada de forma (1, 50, 60), lo que significa que debes tomar 50 momentos (por ejemplo, 50 horas de datos hist√≥ricos) y pasarle al modelo una matriz con 60 caracter√≠sticas o variables por cada momento.

        Esto implica organizar los datos en "ventanas" o secuencias de 50 per√≠odos. Esto es crucial para el modelo, ya que las predicciones dependen de los √∫ltimos 50 momentos hist√≥ricos de datos.

¬øC√≥mo Preparar los Datos? 


    Entrada X (Datos Hist√≥ricos):

        Crear una matriz de forma (n_samples, 50, 60), donde cada sample contiene 50 per√≠odos de datos (por ejemplo, 50 horas).

        Cada per√≠odo (momento) debe tener 60 caracter√≠sticas (precios, indicadores y patrones).

    Salida Y (Predicci√≥n):

        El modelo probablemente predecir√° una acci√≥n de compra/venta, o alguna m√©trica relacionada con la variaci√≥n del precio. La salida puede ser un valor relacionado con la direcci√≥n del mercado (sube/baja) o el cambio en puntos del precio.

¬øQu√© Debes Poner en la Entrada del Modelo?

    Precios Hist√≥ricos:

        Precio de apertura, cierre, alto y bajo.

    Indicadores T√©cnicos:

        EMA de 50, 12, y 26.

        MACD (MACD y Signal).

        RSI (√çndice de Fuerza Relativa).

    Patrones de Velas:

        Doji, Hammer, Bullish Engulfing, etc.

Esta ser√° la informaci√≥n que tu modelo espera para hacer las predicciones.

5. ¬øC√≥mo Armar el X_train para el Modelo? En tu c√≥digo de entrenamiento original, deber√≠as haber tenido algo similar a esto para preparar los datos de entrada para el modelo:

X = []
y = []
for i in range(50, len(data)):
    X.append(data[i-50:i, :])  # Tomamos los √∫ltimos 50 momentos de datos
    y.append(data[i, target_index])  # Tomamos la variable objetivo que predice el modelo
    Que los datos de Kraken se preparen en ventanas de 50 per√≠odos, donde cada ventana tiene 60 caracter√≠sticas.

    X_train debe tener la forma (n_samples, 50, 60).

6. C√≥mo Utilizar el Modelo en Producci√≥n:

    Una vez que los datos est√©n listos y organizados como X_train, el modelo ser√° capaz de predecir el comportamiento del mercado.

    El modelo te dar√° una predicci√≥n sobre la direcci√≥n del mercado, cu√°nto va a subir o bajar el precio, o un se√±al de compra/venta.


  
        RESUMEN

Indicadores t√©cnicos calculados (EMA, MACD, RSI, patrones de velas).

Datos normalizados y procesados en una forma de ventanas de 50 per√≠odos.

Matriz de entrada X en el formato (n_samples, 50, 60) donde:

    n_samples es el n√∫mero de muestras que tienes (el n√∫mero de secuencias de datos que puedas usar).

    50 es el n√∫mero de pasos de tiempo (ventanas).

    60 es el n√∫mero de caracter√≠sticas por cada paso de tiempo (precios, indicadores, patrones).

Salidas de predicci√≥n para cada ventana de datos (en forma de y).
